{"componentChunkName":"component---src-templates-blog-post-js","path":"/atWork/modern-file-api/","result":{"data":{"site":{"siteMetadata":{"title":"Today I Learned...","author":"장호현","siteUrl":"https://guest-01.github.io/TIL","comment":{"disqusShortName":"","utterances":"Guest-01/blog-comments"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"8ac2f13c-cf51-556b-8d05-8e9194201914","excerpt":"회사 솔루션에서 백오피스 특성상, CSV 가져오기/내보내기를 구현할 일이 있었습니다. 사용자가 본인이 가진 기기의 MAC주소를 등록하는 화면이 있었는데 이때 UI에서는 한개씩만 등록할 수 있게 되어있었기 때문이죠. UI상에서 여러개를 등록할 수 있게 개선할 수도 있지만, 그보다는 엑셀형태(정확히는 CSV)로 관리하는 방식을 관리자들이 선호했기 때문에 대신 CSV파일을 업로드하여 여러개의 MAC…","html":"<p>회사 솔루션에서 백오피스 특성상, CSV 가져오기/내보내기를 구현할 일이 있었습니다. 사용자가 본인이 가진 기기의 MAC주소를 등록하는 화면이 있었는데 이때 UI에서는 한개씩만 등록할 수 있게 되어있었기 때문이죠.</p>\n<p>UI상에서 여러개를 등록할 수 있게 개선할 수도 있지만, 그보다는 엑셀형태(정확히는 CSV)로 관리하는 방식을 관리자들이 선호했기 때문에 대신 CSV파일을 업로드하여 여러개의 MAC 주소를 한번에 입력할 수 있게 해달라고 했습니다.</p>\n<p>이를 구현하기 위해서는 먼저 사용자가 우리 웹에 파일을 업로드할 수 있게 해주어야 했죠. 하지만 제가 백엔드 개발자로부터 받은 API는 파일(Binary)을 받는 것이 아니라 MAC주소의 배열이 담긴 JSON을 받는 API였습니다. 그렇다면 파일을 그대로 서버로 전송하는 것이 아닌, <strong>제가 직접 파일을 파싱한 후 JSON으로 만들어서 보내야하는 상황</strong>이었습니다.</p>\n<h3 id=\"고전적인-파일-전송-방법\" style=\"position:relative;\"><a href=\"#%EA%B3%A0%EC%A0%84%EC%A0%81%EC%9D%B8-%ED%8C%8C%EC%9D%BC-%EC%A0%84%EC%86%A1-%EB%B0%A9%EB%B2%95\" aria-label=\"고전적인 파일 전송 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>고전적인 파일 전송 방법</h3>\n<p>html에는 이미 오래전부터 파일 입출력을 받을 수 있는 방법이 있었습니다. 바로 <code class=\"language-text\">&lt;input type=\"file\" /></code>과 <code class=\"language-text\">&lt;a download /></code>이죠. 하지만 이것들은 html이기 때문에 어떤 로직을 추가하고 싶거나 파일을 핸들링하고 싶다면 자바스크립트로 해당 태그(HTMLElement)를 먼저 가져오는 등, DOM 조작을 필요로 했습니다. 즉, 지금처럼 백엔드에 그대로 보내는 것이 아닌 파싱 같은 작업을 해야할 때는 약간 번거로운 추가 과정이 필요해집니다. 그래서 저는 자바스크립트에서 바로 파일 선택창을 띄울 수 있는 메소드는 없는지 찾아보았습니다.</p>\n<h3 id=\"최신-file-system-access-api\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%8B%A0-file-system-access-api\" aria-label=\"최신 file system access api permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최신 File System Access API</h3>\n<p>현대 브라우저들은 이런 필요에 의해 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API\">File System Access API</a>를 만들게 되었습니다. 이 API를 이용하면 자바스크립트에서 파일 선택창, 혹은 저장창을 바로 띄워줄 수 있습니다. 그리고 변수에 바로 파일을 담을 수 있죠. 이것은 더이상 사용자가 input을 클릭하길 기다릴 필요가 없다는 뜻입니다. 개발자가 원하는 타이밍이나 이벤트에 파일 업로드/다운로드를 바로 진행시킬 수 있다는 뜻입니다.</p>\n<p>현재 제가하려는 것은 파일 업로드이므로 아래와 같이 간단하게 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>fileHandle<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> window<span class=\"token punctuation\">.</span><span class=\"token function\">showOpenFilePicker</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> file <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> fileHandle<span class=\"token punctuation\">.</span><span class=\"token function\">getFile</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> text <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> file<span class=\"token punctuation\">.</span><span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 함수를 실행하면 사용자에게 파일 선택 모달을 띄우고 파일이 선택된 경우 그 내용을 string으로 가져옵니다. 사용자가 파일을 선택하길 기다려야하기 때문에 비동기로 되어있는 점을 참고해주세요.</p>\n<h3 id=\"그러나-호환성은\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%AC%EB%82%98-%ED%98%B8%ED%99%98%EC%84%B1%EC%9D%80\" aria-label=\"그러나 호환성은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그러나… 호환성은?</h3>\n<p>고전적인 input 대신 파일 선택창을 열어주는 메소드인 <code class=\"language-text\">showOpenFilePicker()</code>는 크롬과 엣지에서 2020년 10월 경부터 지원하는 메소드입니다. 하지만 Firefox나 Safari, 그리고 모바일용 브라우저에서는 전부 지원되지 않아서 다소 호환성이 떨어지므로 주의할 필요가 있습니다.</p>\n<p>파일 선택 후 얻어지는 <code class=\"language-text\">FileSystemFileHandle</code> 인터페이스의 경우는 현재 모든 모던 브라우저에서 호환이 되지만, Firefox는 비교적 최근인 2023-03-14 버전부터 지원되기 시작했으므로 역시나 완벽하게 안심할 수는 없습니다.</p>\n<p>그리고 <code class=\"language-text\">fileHandle.getFile()</code> 로 얻어지는 <code class=\"language-text\">File</code> 인터페이스 객체는 오래전부터 Blob의 자식 클래스로 제공되고 있었던 것이므로 이 부분만은 문제가 없겠네요.</p>\n<h3 id=\"polyfill-정확히는-ponyfill\" style=\"position:relative;\"><a href=\"#polyfill-%EC%A0%95%ED%99%95%ED%9E%88%EB%8A%94-ponyfill\" aria-label=\"polyfill 정확히는 ponyfill permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Polyfill (정확히는 Ponyfill)</h3>\n<p>따라서 호환성을 위해서는 여전히 고전적인 input/a 태그 방식을 사용할 필요가 있겠습니다. 하지만 이런 고민을 우리가 처음한 것이 아닐 것이란 생각에 조금 검색해보니, 무려 크롬개발자들이 만든 라이브러리가 있었습니다.</p>\n<ul>\n<li><a href=\"https://github.com/GoogleChromeLabs/browser-fs-access\">https://github.com/GoogleChromeLabs/browser-fs-access</a></li>\n</ul>\n<p>이 <code class=\"language-text\">browser-fs-access</code>라는 이름의 라이브러리는 파일 입출력에 대한 추상화된 함수를 제공합니다. 예를 들어 여기에서 제공하는 <code class=\"language-text\">fileOpen</code> 함수를 이용하면, 지원되는 최신 브라우저에서는 위와 같은 <code class=\"language-text\">showOpenFilePicker()</code>를 사용하고, 지원되지 않는 브라우저에서는 알아서 기존의 input 태그 방식으로 fallback시킵니다.</p>\n<blockquote>\n<p>This module allows you to easily use the File System Access API on supporting browsers, with a transparent fallback to the <code class=\"language-text\">&lt;input type=\"file\"></code> and <code class=\"language-text\">&lt;a download></code> legacy methods. This library is a ponyfill.</p>\n</blockquote>\n<p>(라이브러리의 README.md 첫 문장)</p>\n<p>앞으로 서버(API)에서 파일 업로드/다운로드를 직접 지원하지 않는 다면 위 라이브러리가 큰 도움이될 것 같습니다.</p>","frontmatter":{"title":"프론트엔드에서 파일 입출력 다루기","date":"July 25, 2023"}}},"pageContext":{"slug":"/atWork/modern-file-api/","previous":{"fields":{"slug":"/atWork/overflow-in-table/"},"frontmatter":{"title":"테이블 셀 안의 내용이 너무 길 때"}},"next":null}}}